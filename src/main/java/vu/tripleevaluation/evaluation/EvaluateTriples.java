package vu.tripleevaluation.evaluation;

import vu.tripleevaluation.io.TripleSaxParser;
import vu.tripleevaluation.objects.Triple;
import vu.tripleevaluation.statistics.Statistics;
import vu.tripleevaluation.util.Util;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

/**
 * Created by IntelliJ IDEA.
 * User: kyoto.Piek.Vossen (p.vossen@let.vu.nl)
 * Date: Aug 26, 2010
 * Time: 9:52:11 AM
 * This is a package for evaluating text mining. The evaluation module assume that any mined data is converted to Triples.
 * The program reads a file with Triples that represents the standard and another file with Triples that is generated by the system.
 * It calculates the precision and recall for the system file, where the following definitions are used:
 *
 * Precision = nCorrect system Triples/n gold standard Triples
 * Recall = nCorrect system Triples/nr of system Triples
 *
 *
 *
 * A Triple consists of:
 *  - a relation
 *  - a list of token ids that represent the first element, e.g. an event
 *  - a list of token ids that represent the second element, e.g. participant
 *
 * Four evaluations are carried out by comparing the Triple in four ways:
 *
 *  - all identifiers and the relation exactly match
 *  - all identifiers match and the relation is ignored
 *  - at least one identifier matches and the relation matches
 *  - at least one identifier matches and the relation is ignored
 *
 * So that systems cannot cheat by making very long ranges of first elements Ids and second element Ids, we publish the average size of the ranges
 *
 * The program requires the kaf SaxParser as a dependent package
 *
 * This file is part of KybotEvaluation.

 KybotEvaluation is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 KybotEvaluation is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with KybotEvaluation.  If not, see <http://www.gnu.org/licenses/>.
 */


public class EvaluateTriples {

    private HashMap<String, Statistics> relationMap = new HashMap<String, Statistics>();

    public boolean ignoreRelations = false;
    public boolean timeAndLocation = true;
    public boolean elementSecondMatch = true;
    private ArrayList<String> tokenRange;
    private int nGoldTriples;
    private int nSystemTriples;
    private double dExactIdExactRelationPrecision;
    private double dExactIdExactRelationRecall;
    private double dPartialIdExactRelationPrecision;
    private double dPartialIdExactRelationRecall;
    private double dExactIdPrecision;
    private double dExactIdRecall;
    private double dPartialIdPrecision;
    private double dPartialIdRecall;


    public TripleSaxParser goldParser;
    public TripleSaxParser systemParser;
    FileOutputStream fos;
    FileOutputStream log;
    ArrayList<Triple> notCoveredTriples;
    ArrayList<Triple> wrongIdTriples;
    ArrayList<Triple> wrongRelationTriples;

    //// Needed to count correct Triples only once
    ArrayList<Triple> correctPartialIdExactRelationTriples;
    ArrayList<Triple> correctExactIdTriples;
    ArrayList<Triple> correctExactIdExactRelationTriples;
    ArrayList<Triple> correctPartialIdTriples;

    ArrayList<Triple> uniquePartialIdExactRelationTriples;
    ArrayList<Triple> uniqueExactIdTriples;
    ArrayList<Triple> uniqueExactIdExactRelationTriples;
    ArrayList<Triple> uniquePartialIdTriples;
    ArrayList<Triple> uniqueSystemRelationTriples;
    HashMap<String, HashMap<String, Integer>> profileConfusionMatrix;

    public EvaluateTriples () {
        ignoreRelations = false;
        timeAndLocation = true;
        elementSecondMatch = true;
        init();
    }

    void init () {
        relationMap = new HashMap<String, Statistics>();
        tokenRange = new ArrayList<String>();
        goldParser = new TripleSaxParser();
        systemParser = new TripleSaxParser();
        nGoldTriples = 0;
        nSystemTriples = 0;
        dExactIdExactRelationPrecision = 0;
        dExactIdExactRelationRecall = 0;
        dPartialIdExactRelationPrecision = 0;
        dPartialIdExactRelationRecall = 0;
        dExactIdPrecision = 0;
        dExactIdRecall = 0;
        dPartialIdPrecision = 0;
        dPartialIdRecall = 0;

        correctPartialIdExactRelationTriples = new ArrayList<Triple>();
        correctExactIdTriples = new ArrayList<Triple>();
        correctExactIdExactRelationTriples = new ArrayList<Triple>();
        correctPartialIdTriples = new ArrayList<Triple>();

        uniquePartialIdExactRelationTriples = new ArrayList<Triple>();
        uniqueExactIdTriples = new ArrayList<Triple>();
        uniqueExactIdExactRelationTriples = new ArrayList<Triple>();
        uniquePartialIdTriples = new ArrayList<Triple>();

        uniqueSystemRelationTriples = new ArrayList<Triple>();

        notCoveredTriples = new ArrayList<Triple>();
        wrongIdTriples = new ArrayList<Triple>();
        wrongRelationTriples = new ArrayList<Triple>();

        profileConfusionMatrix = new HashMap<String, HashMap<String, Integer>>();
    }

    public ArrayList<Triple> getCorrectExactIdExactRelationTriples() {
        return correctExactIdExactRelationTriples;
    }

    public void setCorrectExactIdExactRelationTriples(ArrayList<Triple> correctExactIdExactRelationTriples) {
        this.correctExactIdExactRelationTriples = correctExactIdExactRelationTriples;
    }

    public ArrayList<Triple> getCorrectExactIdTriples() {
        return correctExactIdTriples;
    }

    public void setCorrectExactIdTriples(ArrayList<Triple> correctExactIdTriples) {
        this.correctExactIdTriples = correctExactIdTriples;
    }

    public ArrayList<Triple> getCorrectPartialIdExactRelationTriples() {
        return correctPartialIdExactRelationTriples;
    }

    public void setCorrectPartialIdExactRelationTriples(ArrayList<Triple> correctPartialIdExactRelationTriples) {
        this.correctPartialIdExactRelationTriples = correctPartialIdExactRelationTriples;
    }

    public ArrayList<Triple> getCorrectPartialIdTriples() {
        return correctPartialIdTriples;
    }

    public void setCorrectPartialIdTriples(ArrayList<Triple> correctPartialIdTriples) {
        this.correctPartialIdTriples = correctPartialIdTriples;
    }

    public double getdExactIdExactRelationPrecision() {
        return dExactIdExactRelationPrecision;
    }

    public void setdExactIdExactRelationPrecision(double dExactIdExactRelationPrecision) {
        this.dExactIdExactRelationPrecision = dExactIdExactRelationPrecision;
    }

    public double getdExactIdExactRelationRecall() {
        return dExactIdExactRelationRecall;
    }

    public void setdExactIdExactRelationRecall(double dExactIdExactRelationRecall) {
        this.dExactIdExactRelationRecall = dExactIdExactRelationRecall;
    }

    public double getdExactIdPrecision() {
        return dExactIdPrecision;
    }

    public void setdExactIdPrecision(double dExactIdPrecision) {
        this.dExactIdPrecision = dExactIdPrecision;
    }

    public double getdExactIdRecall() {
        return dExactIdRecall;
    }

    public void setdExactIdRecall(double dExactIdRecall) {
        this.dExactIdRecall = dExactIdRecall;
    }

    public double getdPartialIdExactRelationRecall() {
        return dPartialIdExactRelationRecall;
    }

    public void setdPartialIdExactRelationRecall(double dPartialIdExactRelationRecall) {
        this.dPartialIdExactRelationRecall = dPartialIdExactRelationRecall;
    }

    public double getdPartialIdPrecision() {
        return dPartialIdPrecision;
    }

    public void setdPartialIdPrecision(double dPartialIdPrecision) {
        this.dPartialIdPrecision = dPartialIdPrecision;
    }

    public double getdPartialIdExactRelationPrecision() {
        return dPartialIdExactRelationPrecision;
    }

    public void setdPartialIdExactRelationPrecision(double dPartialIdExactRelationPrecision) {
        this.dPartialIdExactRelationPrecision = dPartialIdExactRelationPrecision;
    }

    public double getdPartialIdRecall() {
        return dPartialIdRecall;
    }

    public void setdPartialIdRecall(double dPartialIdRecall) {
        this.dPartialIdRecall = dPartialIdRecall;
    }

    public int getnGoldTriples() {
        return nGoldTriples;
    }

    public void setnGoldTriples(int nGoldTriples) {
        this.nGoldTriples = nGoldTriples;
    }

    public int getnSystemTriples() {
        return nSystemTriples;
    }

    public void setnSystemTriples(int nSystemTriples) {
        this.nSystemTriples = nSystemTriples;
    }

    public HashMap<String, Statistics> getRelationMap() {
        return relationMap;
    }

    public void setRelationMap(HashMap<String, Statistics> relationMap) {
        this.relationMap = relationMap;
    }

    public ArrayList<Triple> getUniqueExactIdExactRelationTriples() {
        return uniqueExactIdExactRelationTriples;
    }

    public void setUniqueExactIdExactRelationTriples(ArrayList<Triple> uniqueExactIdExactRelationTriples) {
        this.uniqueExactIdExactRelationTriples = uniqueExactIdExactRelationTriples;
    }

    public ArrayList<Triple> getUniqueExactIdTriples() {
        return uniqueExactIdTriples;
    }

    public void setUniqueExactIdTriples(ArrayList<Triple> uniqueExactIdTriples) {
        this.uniqueExactIdTriples = uniqueExactIdTriples;
    }

    public ArrayList<Triple> getUniquePartialIdExactRelationTriples() {
        return uniquePartialIdExactRelationTriples;
    }

    public void setUniquePartialIdExactRelationTriples(ArrayList<Triple> uniquePartialIdExactRelationTriples) {
        this.uniquePartialIdExactRelationTriples = uniquePartialIdExactRelationTriples;
    }

    public ArrayList<Triple> getUniquePartialIdTriples() {
        return uniquePartialIdTriples;
    }

    public void setUniquePartialIdTriples(ArrayList<Triple> uniquePartialIdTriples) {
        this.uniquePartialIdTriples = uniquePartialIdTriples;
    }

    public ArrayList<Triple> getUniqueSystemRelationTriples() {
        return uniqueSystemRelationTriples;
    }

    public void setUniqueSystemRelationTriples(ArrayList<Triple> uniqueSystemRelationTriples) {
        this.uniqueSystemRelationTriples = uniqueSystemRelationTriples;
    }

    public String compareTripleFiles (String goldStandardFile, String systemFile) {
        init();
        String str = "";
        //// We set the token range for the systemParser.
        //// This means that we only consider system Triples if
        //// the first element identifiers of the Triple match some first element identifier of the gold standard
        systemParser.tokenRange = tokenRange;
        systemParser.timeAndLocation = timeAndLocation;
        systemParser.parseFile(systemFile);
        goldParser.timeAndLocation = timeAndLocation;
        goldParser.parseFile(goldStandardFile);
        this.nSystemTriples = systemParser.data.size();
        this.nGoldTriples = goldParser.data.size();

        /// First we build a map for the relations in the gold-standard and count the number of gold Triples,
        // this is used to calculate recall per relation
        for (int i = 0; i < goldParser.data.size(); i++) {
            Triple TripleG = goldParser.data.get(i);
            if (relationMap.containsKey(TripleG.getRelation())) {
                Statistics stat = relationMap.get(TripleG.getRelation());
                stat.incrementTotalGold();
                relationMap.put(TripleG.getRelation(), stat);
            }
            else {
                Statistics stat = new Statistics();
                stat.setTotalGold(1);
                relationMap.put(TripleG.getRelation(), stat);
            }
        }
        //// Next we iterate over the Triples of the system
        for (int i = 0; i < systemParser.data.size(); i++) {
            Triple TripleS = systemParser.data.get(i);

            /// we check of the system Triple is already covered,
            // if we have a type of match we put the gold standard Triple in a list
            // It can only be matched once.
            if (!Util.hasTriplePartialIdExactRelation(TripleS, this.uniquePartialIdExactRelationTriples)) {
               this.uniquePartialIdExactRelationTriples.add(TripleS);
            }
            if (!Util.hasTriplePartialId(TripleS, this.uniquePartialIdTriples)) {
               this.uniquePartialIdTriples.add(TripleS);
            }

            //// To calculate the precision for a relation we store all Triples that propose a relation.
            //// If system Triples for the same relation have overlapping IDs for both first and second elements, we skip it
            if (relationMap.containsKey(TripleS.getRelation())) {
                Statistics stat = relationMap.get(TripleS.getRelation());
                /// we check if there is already a Triple for this relation with a partial ID match
                /// if not, we add this Triple, if so we skipp it
                if (!Util.hasTriplePartialId(TripleS, stat.getUniqueSystemTriples())) {
                    stat.getUniqueSystemTriples().add(TripleS);
                    relationMap.put(TripleS.getRelation(), stat);
                }
                else {
                    //// DO NOTHING
                }
            }
            else {
                Statistics stat = new Statistics();
                stat.getUniqueSystemTriples().add(TripleS);
                relationMap.put(TripleS.getRelation(), stat);
            }

            //We check the system Triple against all gold Triples
            for (int j = 0; j < goldParser.data.size(); j++) {
                Triple TripleG = goldParser.data.get(j);
                if (ignoreRelations) {
                    if (Util.compareTriplesPartialId(TripleG, TripleS)) {
                        if (!Util.hasTriplePartialId(TripleG, correctPartialIdTriples )) {
                        /// avoid counting duplicate system Triples
                            correctPartialIdTriples.add(TripleG);
                            if (relationMap.containsKey(TripleG.getRelation())) {
                                Statistics stat = relationMap.get(TripleG.getRelation());
                                stat.incrementCorrectPartialIdExactRelation();
                                relationMap.put(TripleG.getRelation(), stat);
                            }
                            else { /// should not occur since we added all gold standard Triples before we started
                            }
                        }
                        else {
                            //// should not occur since this is the first
                        }
                        /// we have a match so we can break;
                        break;
                    }
                }
                else {
                    if (Util.compareTriplesPartialIdExactRelation(TripleG, TripleS, elementSecondMatch)) {
                        if (!Util.hasTriplePartialIdExactRelation(TripleG, correctPartialIdExactRelationTriples )) {
                        /// avoid counting duplicate system Triples
                            correctPartialIdExactRelationTriples.add(TripleG);
                            if (relationMap.containsKey(TripleG.getRelation())) {
                                Statistics stat = relationMap.get(TripleG.getRelation());
                                stat.incrementCorrectPartialIdExactRelation();
                                relationMap.put(TripleG.getRelation(), stat);
                            }
                            else { /// should not occur since we added all gold standard Triples before we started
                            }
                        }
                        else {
                            //// should not occur since this is the first
                        }
                        /// we have a match so we can break;
                        break;
                    }
                }
            }
        }


        int relationCorrectPartial = 0;
        int relationGold = 0;
        int relationSystem = 0;
        str += "\nResults per relation\n";
        Set keySet = relationMap.keySet();
        Iterator keys = keySet.iterator();
        str += "Relation\tTotal gold\tProportion Gold\tTotal system\tProportion system\tPartialIdExactRelation\tRecall\tPrecision\n";
        while (keys.hasNext()) {
            String key = (String) keys.next();
            Statistics stat = relationMap.get(key);
            stat.totalSystem = stat.uniqueSystemTriples.size();
            relationCorrectPartial += stat.getCorrectPartialIdExactRelation();
            relationGold += stat.getTotalGold();
            relationSystem += stat.getTotalSystem();
            Double perc1 = 100*(double)stat.getTotalGold()/(double)nGoldTriples;
            Double perc2 = 100*(double)stat.getTotalSystem()/(double)nSystemTriples;
            str += key+stat.toStringPartialRelation(perc1.intValue(), perc2.intValue());
        }
        int totalPartialRecall = 0;
        int totalPartialPrecision = 0;
        if (relationGold>0) totalPartialRecall = (100*relationCorrectPartial)/relationGold;
        if (relationSystem>0) totalPartialPrecision = (100*relationCorrectPartial)/relationSystem;
        str += "Total\t"+relationGold+"\t"+"\t"+relationSystem+"\t"+"\t"+relationCorrectPartial+"\t"+totalPartialRecall+"\t"+totalPartialPrecision+"\n";
        return str;
    }

    public String printResults (String goldFile, String systemFile) {
        String str = "\nPrecision and recall figures\n";
        str += "Gold standard\t"+goldFile+"\n";
        str += "\tNr. of Triples\t"+this.nGoldTriples+"\n";
        str += "\tAverage nr. of first element ids\t"+goldParser.getAverageElementFirstIdRange()+"\n";
        str += "\tAverage nr. of second element ids\t"+goldParser.getAverageElementSecondIdRange()+"\n";
        str += "\nSystem file\t"+systemFile+"\n";
        str += "\tNr. of Triples in total\t"+(this.nSystemTriples+systemParser.outOfRangeCount)+"\n";
        str += "\tNr. of Triples in range\t"+this.nSystemTriples+"\n";
        str += "\tNr. of Triples out of range\t"+systemParser.outOfRangeCount+"\n";
        str += "\tAverage nr. of first element ids\t"+systemParser.getAverageElementFirstIdRange()+"\n";
        str += "\tAverage nr. of second element ids\t"+systemParser.getAverageElementSecondIdRange()+"\n";
        str += "\tNumber of unique Triples in scope\t"+uniquePartialIdExactRelationTriples.size()+"\n";
        str += "\n";
        str += "\tNumber of first elements represented in gold standard Triples\t"+(goldParser.nUniqueElementsFirst())+"\n";
        str += "\tNumber of first elements represented in system Triples\t"+(systemParser.nUniqueElementsFirst())+"\n";
        str += "\tNumber of correct first elements represented in system Triples\t"+(systemParser.nUniqueElementsFirstInData())+"\n";
        str += "\tRecall of first elements\t"+(double)systemParser.nUniqueElementsFirstInData()/(double)goldParser.nUniqueElementsFirst()+"\n";
        str += "\tPrecision of first elements\t"+(double)systemParser.nUniqueElementsFirstInData()/(double)systemParser.nUniqueElementsFirst()+"\n";
       // str += goldParser.printElementsFirstInData()+"\n";
       // str += systemParser.printElementsFirstInData()+"\n";

        str += "\n";
        str += "\tNumber of second elements represented in gold standard Triples\t"+(goldParser.nUniqueElementsSecond())+"\n";
        str += "\tNumber of second elements represented in system Triples\t"+(systemParser.nUniqueElementsSecond())+"\n";
        str += "\tNumber of correct second elements represented in system Triples\t"+(systemParser.nUniqueElementsSecondInData())+"\n";
        str += "\tRecall of second elements\t"+(double)systemParser.nUniqueElementsSecondInData()/(double)goldParser.nUniqueElementsSecond()+"\n";
        str += "\tPrecision of second elements\t"+(double)systemParser.nUniqueElementsSecondInData()/(double)systemParser.nUniqueElementsSecond()+"\n";
       //  str += goldParser.printElementsSecondInData()+"\n";
       //  str += systemParser.printElementsSecondInData()+"\n";



        System.out.println("this.nUniquePartialIdExactRelationTriples.size() = " + this.uniquePartialIdExactRelationTriples.size());
        dPartialIdExactRelationPrecision = (double)this.correctPartialIdExactRelationTriples.size() /(double)this.uniquePartialIdExactRelationTriples.size();
        dPartialIdExactRelationRecall = (double)this.correctPartialIdExactRelationTriples.size() /(double)this.nGoldTriples;
        dPartialIdPrecision = (double)this.correctPartialIdTriples.size() /(double)this.uniquePartialIdTriples.size();
        dPartialIdRecall = (double)this.correctPartialIdTriples.size() /(double)this.nGoldTriples;
        if (ignoreRelations) {
            str += "\nPartial identifiers and ignored relation\n";
            str += "\tNr. correct\t"+ correctPartialIdTriples.size() +"\n";
            str += "\tPrecision\t"+ dPartialIdPrecision +"\n";
            str += "\tRecall\t"+ dPartialIdRecall+"\n";
        }
        else {
            str += "\nPartial identifiers and same relation\n";
            str += "\tNr. correct\t"+ correctPartialIdExactRelationTriples.size() +"\n";
            str += "\tPrecision\t"+ dPartialIdExactRelationPrecision+"\n";
            str += "\tRecall\t"+ dPartialIdExactRelationRecall +"\n";
            str+="\n\t"+"Nr of Triples\tTriples inscope\tCorrect\tWSD threshold\tPrecision\tRecall\n";
            str+=""+systemFile+"\t"+(this.nSystemTriples+systemParser.outOfRangeCount)+"\t"+uniquePartialIdExactRelationTriples.size()+"\t"+correctPartialIdExactRelationTriples.size()+"\t\t"+dPartialIdExactRelationPrecision+"\t"+ dPartialIdExactRelationRecall +"\n";
            str+= "\n\t"+"Nr First Elements\tCorrect\tRecall\tPrecision\n";
            str+= systemFile+"\t"+systemParser.nUniqueElementsFirst()+"\t"+systemParser.nUniqueElementsFirstInData()+"\t"+(double)systemParser.nUniqueElementsFirstInData()/(double)goldParser.nUniqueElementsFirst()+"\t"+(double)systemParser.nUniqueElementsFirstInData()/(double)systemParser.nUniqueElementsFirst()+"\n";
        }

        return str;
    }


    public String readTokenRange (String tokenRangeFile) {
        String str = "";
        try {
          str += "tokenRangeFile:\t" + tokenRangeFile+"\n";
          FileInputStream fis = new FileInputStream(tokenRangeFile);
          InputStreamReader isr = new InputStreamReader(fis);
          BufferedReader in = new BufferedReader(isr);
          String inputLine;
          while ((inputLine = in.readLine()) != null) {
              String token = inputLine.trim();
              if (token.length()>0) {
                  if (!tokenRange.contains(token)) {
                      tokenRange.add(token);
                  }
              }
          }
          in.close();
          str += "tokenRange:\t" + tokenRange.size()+"\n";
        }
        catch (Exception eee) {
          String error = "\nException --"+eee.getMessage();
          System.out.println(error);
        }
        return str;
    }

    static public void main (String[] args) {
        EvaluateTriples evaluation = new EvaluateTriples();
        String goldStandardTripleFile = "";
        String systemTripleFile = "";
        String tokenRangeFile = "";
        for (int i = 0; i < args.length; i++) {
            String arg = args[i];
            if (arg.equalsIgnoreCase("--gold-standard-triples")) {
               if (i+1<args.length) {
                    goldStandardTripleFile = args[i+1];
               }
               else {
                   System.out.println("NO FILE PROVIDED AS GOLD STANDARD!");
               }
            }
            else if (arg.equalsIgnoreCase("--system-triples")) {
                if (i+1<args.length) {
                   systemTripleFile = args[i+1];
                }
                else {
                    System.out.println("NO FILE PROVIDED AS SYSTEM FILE!");
                }
            }
            else if (arg.equalsIgnoreCase("--token-range")) {
                if (i+1<args.length) {
                   tokenRangeFile = args[i+1];

                }
                else {
                    System.out.println("NO FILE PROVIDED AS TOKEN RANGE!");
                }
            }
            else if (arg.equalsIgnoreCase("--ignore-element-second")) {
                evaluation.elementSecondMatch = false;
            }
            else if (arg.equalsIgnoreCase("--ignore-relations")) {
                evaluation.ignoreRelations = true;
            }
            else if (arg.equalsIgnoreCase("--skip-time-and-location")) {
                evaluation.timeAndLocation = false;

            }
        }
        if ((goldStandardTripleFile.length()>0) && (systemTripleFile.length()>0)) {
            try {
                evaluation.fos = new FileOutputStream(systemTripleFile+".xls");
                evaluation.log = new FileOutputStream(systemTripleFile+".log");
                System.out.println("goldStandardTripleFile = " + goldStandardTripleFile);
                System.out.println("systemTripleFile = " + systemTripleFile);
                System.out.println("tokenRangeFile = " + tokenRangeFile);
                System.out.println("evaluation.timeAndLocation = " + evaluation.timeAndLocation);
                String str ="";
                if (tokenRangeFile.length()>0) {
                    str = evaluation.readTokenRange(tokenRangeFile);
                    evaluation.fos.write(str.getBytes());
                }
                str = evaluation.compareTripleFiles(goldStandardTripleFile, systemTripleFile);
                evaluation.fos.write(str.getBytes());
                str = evaluation.printResults(new File(goldStandardTripleFile).getName(), new File(systemTripleFile).getName());
                evaluation.fos.write(str.getBytes());
                evaluation.fos.close();
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }
        }
        else {
            String usage = "";
            usage += "--gold-standard-triples file with gold standard triples\n";
            usage += "--system-triples file with system triples\n";
            usage += "--token-range (optional) file with tokens for the first elements to be covered\n";
            usage += "--ignore-element-second (optional) lumps differentiated second elements as a single typed relation\n";
            usage += "--ignore-relations (optional) relation labels are ignored for matching\n";
            usage += "--skip-time-and-location (optional) TIME and LOCATION relations are ignored\n";
            System.out.println("usage =\n" + usage);
        }
    }

}
