package vu.tripleevaluation.evaluation;

import vu.tripleevaluation.io.TripleSaxParser;
import vu.tripleevaluation.objects.Triple;
import vu.tripleevaluation.statistics.Statistics;
import vu.tripleevaluation.util.Util;

import java.io.*;
import java.util.*;

/**
 * Created by IntelliJ IDEA.
 * User: kyoto.Piek.Vossen (p.vossen@let.vu.nl)
 * Date: Aug 26, 2010
 * Time: 9:52:11 AM
 * This is a package for evaluating text mining. The evaluation module assume that any mined data is converted to Triples.
 * The program reads a file with Triples that represents the standard and another file with Triples that is generated by the system.
 * It calculates the precision and recall for the system file, where the following definitions are used:
 *
 * Precision = nCorrect system Triples/n gold standard Triples
 * Recall = nCorrect system Triples/nr of system Triples
 *
 *
 *
 * A Triple consists of:
 *  - a relation
 *  - a list of token ids that represents the first elements, e.g. an event
 *  - a list of token ids that represents the second elements, e.g. a participant
 *
 * Four evaluations are carried out by comparing the Triple in four ways:
 *
 *  - all identifiers and the relation exactly match
 *  - all identifiers match and the relation is ignored
 *  - at least one identifier matches and the relation matches
 *  - at least one identifier matches and the relation is ignored
 *
 * So that systems cannot cheat by making very long ranges of first element Ids and second element Ids, we publish the average size of the ranges
 *
 * The program requires the kaf SaxParser as a dependent package

 * This file is part of KybotEvaluation.

 KybotEvaluation is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 KybotEvaluation is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with KybotEvaluation.  If not, see <http://www.gnu.org/licenses/>.
 */


public class EvaluateTriplesDebug {

    public boolean timeAndLocation = true;
    public boolean elementSecondMatch = true;
    private ArrayList<String> tokenRange;
    private int nGoldTriples;
    private int nSystemTriples;
    private double dExactIdExactRelationPrecision;
    private double dExactIdExactRelationRecall;
    private double dPartialIdExactRelationPrecision;
    private double dParialIdExactRelationRecall;
    private double dExactIdPrecision;
    private double dExactIdRecall;
    private double dPartialIdPrecision;
    private double dPartialIdRecall;

    private HashMap<String, Statistics> profileMap = new HashMap<String, Statistics>();
    private HashMap<String, Statistics> relationMap = new HashMap<String, Statistics>();

    public TripleSaxParser goldParser;
    public TripleSaxParser systemParser;
    public FileOutputStream fos;
    public FileOutputStream log;
    public ArrayList<Triple> notCoveredTriples;
    ArrayList<Triple> wrongIdTriples;
    public ArrayList<Triple> wrongRelationTriples;

    //// Needed to count correct Triples only once
    ArrayList<Triple> correctPartialIdExactRelationTriples;
    ArrayList<Triple> correctExactIdTriples;
    ArrayList<Triple> correctExactIdExactRelationTriples;
    ArrayList<Triple> correctPartialIdTriples;

    ArrayList<Triple> uniquePartialIdExactRelationTriples;
    ArrayList<Triple> uniqueExactIdTriples;
    ArrayList<Triple> uniqueExactIdExactRelationTriples;
    ArrayList<Triple> uniquePartialIdTriples;
    ArrayList<Triple> uniqueSystemRelationTriples;
    public HashMap<String, HashMap<String, Integer>> profileConfusionMatrix;
    public HashMap<String, HashMap<String, Integer>> relationConfusionMatrix;

    public ArrayList<String> relationMismatchLog;
    public HashMap<String, Integer> wrongRelationMap = new HashMap<String, Integer> ();
    public HashMap<String, Integer> missedRelationMap = new HashMap<String, Integer> ();

    public EvaluateTriplesDebug() {
        init();
        timeAndLocation = true;
        elementSecondMatch = true;
    }

    void init () {
        profileMap = new HashMap<String, Statistics>();
        relationMap = new HashMap<String, Statistics>();
        relationMismatchLog = new ArrayList<String>();
        tokenRange = new ArrayList<String>();
        goldParser = new TripleSaxParser();
        systemParser = new TripleSaxParser();
        nGoldTriples = 0;
        nSystemTriples = 0;
        dExactIdExactRelationPrecision = 0;
        dExactIdExactRelationRecall = 0;
        dPartialIdExactRelationPrecision = 0;
        dParialIdExactRelationRecall = 0;
        dExactIdPrecision = 0;
        dExactIdRecall = 0;
        dPartialIdPrecision = 0;
        dPartialIdRecall = 0;

        correctPartialIdExactRelationTriples = new ArrayList<Triple>();
        correctExactIdTriples = new ArrayList<Triple>();
        correctExactIdExactRelationTriples = new ArrayList<Triple>();
        correctPartialIdTriples = new ArrayList<Triple>();

        uniquePartialIdExactRelationTriples = new ArrayList<Triple>();
        uniqueExactIdTriples = new ArrayList<Triple>();
        uniqueExactIdExactRelationTriples = new ArrayList<Triple>();
        uniquePartialIdTriples = new ArrayList<Triple>();

        uniqueSystemRelationTriples = new ArrayList<Triple>();

        notCoveredTriples = new ArrayList<Triple>();
        wrongIdTriples = new ArrayList<Triple>();
        wrongRelationTriples = new ArrayList<Triple>();

        profileConfusionMatrix = new HashMap<String, HashMap<String, Integer>>();
        relationConfusionMatrix = new HashMap<String, HashMap<String, Integer>>();
        wrongRelationMap = new HashMap<String, Integer> ();
        missedRelationMap = new HashMap<String, Integer> ();
    }


    public ArrayList<Triple> getCorrectExactIdExactRelationTriples() {
        return correctExactIdExactRelationTriples;
    }

    public void setCorrectExactIdExactRelationTriples(ArrayList<Triple> correctExactIdExactRelationTriples) {
        this.correctExactIdExactRelationTriples = correctExactIdExactRelationTriples;
    }

    public ArrayList<Triple> getCorrectExactIdTriples() {
        return correctExactIdTriples;
    }

    public void setCorrectExactIdTriples(ArrayList<Triple> correctExactIdTriples) {
        this.correctExactIdTriples = correctExactIdTriples;
    }

    public ArrayList<Triple> getCorrectPartialIdExactRelationTriples() {
        return correctPartialIdExactRelationTriples;
    }

    public void setCorrectPartialIdExactRelationTriples(ArrayList<Triple> correctPartialIdExactRelationTriples) {
        this.correctPartialIdExactRelationTriples = correctPartialIdExactRelationTriples;
    }

    public ArrayList<Triple> getCorrectPartialIdTriples() {
        return correctPartialIdTriples;
    }

    public void setCorrectPartialIdTriples(ArrayList<Triple> correctPartialIdTriples) {
        this.correctPartialIdTriples = correctPartialIdTriples;
    }

    public double getdExactIdExactRelationPrecision() {
        return dExactIdExactRelationPrecision;
    }

    public void setdExactIdExactRelationPrecision(double dExactIdExactRelationPrecision) {
        this.dExactIdExactRelationPrecision = dExactIdExactRelationPrecision;
    }

    public double getdExactIdExactRelationRecall() {
        return dExactIdExactRelationRecall;
    }

    public void setdExactIdExactRelationRecall(double dExactIdExactRelationRecall) {
        this.dExactIdExactRelationRecall = dExactIdExactRelationRecall;
    }

    public double getdExactIdPrecision() {
        return dExactIdPrecision;
    }

    public void setdExactIdPrecision(double dExactIdPrecision) {
        this.dExactIdPrecision = dExactIdPrecision;
    }

    public double getdExactIdRecall() {
        return dExactIdRecall;
    }

    public void setdExactIdRecall(double dExactIdRecall) {
        this.dExactIdRecall = dExactIdRecall;
    }

    public double getdParialIdExactRelationRecall() {
        return dParialIdExactRelationRecall;
    }

    public void setdParialIdExactRelationRecall(double dParialIdExactRelationRecall) {
        this.dParialIdExactRelationRecall = dParialIdExactRelationRecall;
    }

    public double getdPartialIdPrecision() {
        return dPartialIdPrecision;
    }

    public void setdPartialIdPrecision(double dPartialIdPrecision) {
        this.dPartialIdPrecision = dPartialIdPrecision;
    }

    public double getdPartialIdExactRelationPrecision() {
        return dPartialIdExactRelationPrecision;
    }

    public void setdPartialIdExactRelationPrecision(double dPartialIdExactRelationPrecision) {
        this.dPartialIdExactRelationPrecision = dPartialIdExactRelationPrecision;
    }

    public double getdPartialIdRecall() {
        return dPartialIdRecall;
    }

    public void setdPartialIdRecall(double dPartialIdRecall) {
        this.dPartialIdRecall = dPartialIdRecall;
    }

    public int getnGoldTriples() {
        return nGoldTriples;
    }

    public void setnGoldTriples(int nGoldTriples) {
        this.nGoldTriples = nGoldTriples;
    }

    public int getnSystemTriples() {
        return nSystemTriples;
    }

    public void setnSystemTriples(int nSystemTriples) {
        this.nSystemTriples = nSystemTriples;
    }

    public HashMap<String, Statistics> getProfileMap() {
        return profileMap;
    }

    public void setProfileMap(HashMap<String, Statistics> profileMap) {
        this.profileMap = profileMap;
    }

    public HashMap<String, Statistics> getRelationMap() {
        return relationMap;
    }

    public void setRelationMap(HashMap<String, Statistics> relationMap) {
        this.relationMap = relationMap;
    }

    public ArrayList<Triple> getUniqueExactIdExactRelationTriples() {
        return uniqueExactIdExactRelationTriples;
    }

    public void setUniqueExactIdExactRelationTriples(ArrayList<Triple> uniqueExactIdExactRelationTriples) {
        this.uniqueExactIdExactRelationTriples = uniqueExactIdExactRelationTriples;
    }

    public ArrayList<Triple> getUniqueExactIdTriples() {
        return uniqueExactIdTriples;
    }

    public void setUniqueExactIdTriples(ArrayList<Triple> uniqueExactIdTriples) {
        this.uniqueExactIdTriples = uniqueExactIdTriples;
    }

    public ArrayList<Triple> getUniquePartialIdExactRelationTriples() {
        return uniquePartialIdExactRelationTriples;
    }

    public void setUniquePartialIdExactRelationTriples(ArrayList<Triple> uniquePartialIdExactRelationTriples) {
        this.uniquePartialIdExactRelationTriples = uniquePartialIdExactRelationTriples;
    }

    public ArrayList<Triple> getUniquePartialIdTriples() {
        return uniquePartialIdTriples;
    }

    public void setUniquePartialIdTriples(ArrayList<Triple> uniquePartialIdTriples) {
        this.uniquePartialIdTriples = uniquePartialIdTriples;
    }

    public ArrayList<Triple> getUniqueSystemRelationTriples() {
        return uniqueSystemRelationTriples;
    }

    public void setUniqueSystemRelationTriples(ArrayList<Triple> uniqueSystemRelationTriples) {
        this.uniqueSystemRelationTriples = uniqueSystemRelationTriples;
    }

    public void compareTripleFiles (String goldStandardFile, String systemFile) {
        ArrayList<String> filter = new ArrayList<String>();
        compareTripleFiles(goldStandardFile, systemFile, filter);
    }

    public void compareTripleFiles (String goldStandardFile, String systemFile, ArrayList<String> relationFilter) {
        init(); /// creates new parser instances.....
        systemParser.relationFilter = relationFilter;
        goldParser.relationFilter = relationFilter;
        int nSystemTriplesInRange = 0;
        //// Next booleans are used to make sure that only one matching Triple is counted, duplicate Triples are ignored,
        // e.g. same ids and same relation
        boolean partialId = false;
        boolean partialIdRelation = false;
        boolean exactId = false;
        boolean exactIdRelation = false;
        //// We set the token range for the systemParser.
        //// This means that we only consider system Triples if
        //// the first element identifiers of the Triple match some first element identifier of the gold standard
        goldParser.timeAndLocation = timeAndLocation;
        // System.out.println("parsing goldStandardFile = " + goldStandardFile);
        goldParser.parseFile(goldStandardFile);
        printStatistics (goldStandardFile, goldParser);
        systemParser.tokenRange = tokenRange;
        systemParser.timeAndLocation = timeAndLocation;
       // System.out.println("parsing systemFile = " + systemFile);
        systemParser.parseFile(systemFile);
        printStatistics (systemFile, systemParser);
        this.nSystemTriples = systemParser.data.size();
        this.nGoldTriples = goldParser.data.size();
        this.notCoveredTriples = Util.copyTriples(goldParser.data);

        /// First we build a map for the relations in the gold-standard and count the number of gold Triples,
        // this is used to calculate recall per relation
        for (int i = 0; i < goldParser.data.size(); i++) {
            Triple TripleG = goldParser.data.get(i);
            if (relationMap.containsKey(TripleG.getRelation())) {
                Statistics stat = relationMap.get(TripleG.getRelation());
                stat.incrementTotalGold();
                relationMap.put(TripleG.getRelation(), stat);
            }
            else {
                Statistics stat = new Statistics();
                stat.setTotalGold(1);
                relationMap.put(TripleG.getRelation(), stat);
            }
        }
        //// Next we iterate over the Triples of the system
        for (int i = 0; i < systemParser.data.size(); i++) {
            Triple TripleS = systemParser.data.get(i);
            nSystemTriplesInRange++;   /// counts how many system Triples are in the range of the gold standard

            /// we check of the system Triple is already covered,
            // if we have a type of match we put the gold standard Triple in a list
            // It can only be matched once.
            if (!Util.hasTriplePartialIdExactRelation(TripleS, this.uniquePartialIdExactRelationTriples)) {
                this.uniquePartialIdExactRelationTriples.add(TripleS);
            }
            if (!Util.hasTripleExactIdExactRelation(TripleS, this.uniqueExactIdExactRelationTriples)) {
               this.uniqueExactIdExactRelationTriples.add(TripleS);
            }
            //System.out.println("EXACT ID IGNORE RELATION");

            if (!Util.hasTripleExactId(TripleS, this.uniqueExactIdTriples)) {
               this.uniqueExactIdTriples.add(TripleS);
            }
            //System.out.println("PARTIAL ID IGNORE RELATION");
            if (!Util.hasTriplePartialId(TripleS, this.uniquePartialIdTriples)) {
               this.uniquePartialIdTriples.add(TripleS);
            }


            //// To calculate the precision for a relation we store all Triples that propose a relation.
            //// If system Triples for the same relation have overlapping IDs for both first and second elements, we skip it
            if (relationMap.containsKey(TripleS.getRelation())) {
                Statistics stat = relationMap.get(TripleS.getRelation());
                /// we check if there is already a Triple for this relation with a partial ID match
                /// if not, we add this Triple, if so we skipp it
                if (!Util.hasTriplePartialId(TripleS, stat.getUniqueSystemTriples())) {
                    stat.getUniqueSystemTriples().add(TripleS);
                    relationMap.put(TripleS.getRelation(), stat);
                }
                else {
                    //// DO NOTHING
                }
            }
            else {
                Statistics stat = new Statistics();
                stat.getUniqueSystemTriples().add(TripleS);
                relationMap.put(TripleS.getRelation(), stat);
            }

            partialId = false;
            partialIdRelation = false;
            exactId = false;
            exactIdRelation = false;

            //We check the system Triple against all gold Triples
            for (int j = 0; j < goldParser.data.size(); j++) {
                Triple TripleG = goldParser.data.get(j);

                ////We build a confusion matrix in case there is a partial id MATCH but relation MISMATCH
                if ((Util.compareTriplesPartialId(TripleG, TripleS)) &&
                    (!TripleG.getRelation().equals(TripleS.getRelation()))) {

                    /// matrix per relation-profile
                    String profileWithRelation = TripleS.getProfileId()+":"+TripleS.getRelation();
                    if (profileConfusionMatrix.containsKey(profileWithRelation)) {
                       HashMap<String, Integer> map = profileConfusionMatrix.get(profileWithRelation);
                       if (map.containsKey(TripleG.getRelation())) {
                           Integer cnt = map.get(TripleG.getRelation());
                           cnt++;
                           map.put(TripleG.getRelation(), cnt);
                       }
                       else {
                           map.put(TripleG.getRelation(), 1);
                       }
                       profileConfusionMatrix.put(profileWithRelation, map);
                    }
                    else {
                       HashMap<String, Integer> map = new HashMap<String, Integer>();
                       map.put(TripleG.getRelation(), 1);
                       profileConfusionMatrix.put(profileWithRelation, map);
                    }

                    /// matrix for relations
                    // System.out.println("TripleS.getRelation() = " + TripleS.getRelation());
                    if (relationConfusionMatrix.containsKey(TripleS.getRelation())) {
                       HashMap<String, Integer> map = relationConfusionMatrix.get(TripleS.getRelation());
                       if (map.containsKey(TripleG.getRelation())) {
                           Integer cnt = map.get(TripleG.getRelation());
                           cnt++;
                           map.put(TripleG.getRelation(), cnt);
                       }
                       else {
                           map.put(TripleG.getRelation(), 1);
                       }
                       relationConfusionMatrix.put(TripleS.getRelation(), map);
                    }
                    else {
                       HashMap<String, Integer> map = new HashMap<String, Integer>();
                       map.put(TripleG.getRelation(), 1);
                       relationConfusionMatrix.put(TripleS.getRelation(), map);
                    }
                    String mismatch = TripleS.getRelation()+":"+TripleS.getElementFirstComment()+":"+TripleS.getElementSecondComment()+"#"+TripleG.getRelation()+":"+TripleG.getElementFirstComment()+":"+TripleG.getElementSecondComment();
                    relationMismatchLog.add(mismatch);
                }

                
                if (!exactIdRelation) {
                    /// So far we did not had a exactIdRelation match
                    if (Util.compareTriplesExactIdExactRelation(TripleG, TripleS, elementSecondMatch)) {
                        //// Now we have the first exactIdRelation match
                       // System.out.println("ID+REL");
                       // System.out.println("TripleS.toString() = " + TripleS.toString());
                       // System.out.println("TripleG.toString() = " + TripleG.toString());
                        if (!Util.hasTripleExactIdExactRelation(TripleG, correctExactIdExactRelationTriples)) {   /// avoid counting duplicate system Triples
                            correctExactIdExactRelationTriples.add(TripleG);
                            if (relationMap.containsKey(TripleG.getRelation())) {
                                Statistics stat = relationMap.get(TripleG.getRelation());
                                stat.incrementCorrectExactIdExactRelation();
                                relationMap.put(TripleG.getRelation(), stat);
                            }
                            else { /// should not occur since we added all gold standard Triples before we started
                            }
                        }
                        else {
                            ///// should not occur since this is the first
                        }
                        exactIdRelation = true;
                      //  removeTriple(TripleG, notCoveredTriples);
                    }
                }
                if (!exactId) {
                    /// so far we did not had an exact Id match
                    if (Util.compareTriplesExactId(TripleG, TripleS)) {
                        //// Now we have the first exactId match, we add it if there is not an exact copy. So now the relation counts.
                        if (!Util.hasTripleExactIdExactRelation(TripleG,correctExactIdTriples)) {    /// avoid counting duplicate system Triples
                            correctExactIdTriples.add(TripleG);
                            if (relationMap.containsKey(TripleG.getRelation())) {
                                Statistics stat = relationMap.get(TripleG.getRelation());
                                stat.incrementCorrectExactId();
                                relationMap.put(TripleG.getRelation(), stat);
                            }
                            else { /// should not occur since we added all gold standard Triples before we started
                            }
                        }
                        else {
                            ///// should not occur since this is the first
                        }
                        exactId = true;
                    //    removeTriple(TripleG, notCoveredTriples);
                    }
                }
                if (!partialIdRelation) {
                    if (Util.compareTriplesPartialIdExactRelation(TripleG, TripleS, elementSecondMatch)) {
                      //  System.out.println("REL");
                      //  System.out.println("TripleS.toString() = " + TripleS.toString());
                      //  System.out.println("TripleG.toString() = " + TripleG.toString());
                        ///we add it if there is not an exact copy. So now the relation counts.
                        if (!Util.hasTripleExactIdExactRelation(TripleG, correctPartialIdExactRelationTriples)) {  /// avoid counting duplicate system Triples
                            correctPartialIdExactRelationTriples.add(TripleG);
                            if (relationMap.containsKey(TripleG.getRelation())) {
                                Statistics stat = relationMap.get(TripleG.getRelation());
                                stat.incrementCorrectPartialIdExactRelation();
                                relationMap.put(TripleG.getRelation(), stat);
                            }
                            else { /// should not occur since we added all gold standard Triples before we started
                            }
                        }
                        else {
                            //// should not occur since this is the first
                        }
                        partialIdRelation = true;
                       // removeTriple(TripleG, notCoveredTriples);
                    }
                }
                if (!partialId) {
                    if (Util.compareTriplesPartialId(TripleG, TripleS)) {
                        ///we add it if there is not an exact copy. So now the relation counts.
                        if (!Util.hasTripleExactIdExactRelation(TripleG, correctPartialIdTriples )) {  /// avoid counting duplicate system Triples
                            correctPartialIdTriples.add(TripleG);
                            if (relationMap.containsKey(TripleG.getRelation())) {
                                Statistics stat = relationMap.get(TripleG.getRelation());
                                stat.incrementCorrectPartialId();
                                relationMap.put(TripleG.getRelation(), stat);
                            }
                            else { /// should not occur
                            }
                        }
                        else {
                            ////// should not occur since this is the first
                        }
                        partialId = true;

                        //// this is specifically for checking recall
                        Util.removeTriple(TripleG, notCoveredTriples);
                    }
                }
            }/// end iterate over the gold standard Triples


            // For the profiles from the system Triples we build a map with the correct Triples
            if (profileMap.containsKey(TripleS.getProfileId())) {
                    Statistics stat = profileMap.get(TripleS.getProfileId());
                    stat.incrementTotalSystem();
               // System.out.println("stat.getTotalSystem() = " + stat.getTotalSystem());
                    if (partialId) {
                        stat.incrementCorrectPartialId();
                    }
                    if (partialIdRelation) {
                        stat.incrementCorrectPartialIdExactRelation();
                    }
                    if (exactId) {
                        stat.incrementCorrectExactId();
                    }
                    if (exactIdRelation) {
                        stat.incrementCorrectExactIdExactRelation();
                    }
                    profileMap.put(TripleS.getProfileId(), stat);
            }
            else {
                Statistics stat = new Statistics();
                stat.setTotalSystem(1);
                if (partialId) {
                    stat.incrementCorrectPartialId();
                }
                if (partialIdRelation) {
                    stat.incrementCorrectPartialIdExactRelation();
                }
                if (exactId) {
                    stat.incrementCorrectExactId();
                }
                if (exactIdRelation) {
                    stat.incrementCorrectExactIdExactRelation();
                }
                profileMap.put(TripleS.getProfileId(), stat);
            }
            if (partialId) {
                if (!partialIdRelation) {
                    if (!Util.hasTriplePartialIdExactRelation(TripleS,wrongRelationTriples)) {
                        wrongRelationTriples.add(TripleS);
                    }
                }
            }
        } //// end iterate over the Triples of the system output


 /*       System.out.println("uniquePartialIdExactRelationTriples = " + uniquePartialIdExactRelationTriples.size());
        System.out.println("uniqueExactIdExactRelationTriples = " + uniqueExactIdExactRelationTriples.size());
        System.out.println("correctPartialIdExactRelationTriples.size() = " + correctPartialIdExactRelationTriples.size());
        System.out.println("correctExactIdExactRelationTriples = " + correctExactIdExactRelationTriples.size());*/
        if (log!=null) {
            try {

                String logstr = "Not covered Triples:"+notCoveredTriples.size()+"\n";
                log.write(logstr.getBytes());
                TreeSet set = Util.sortTriplesForRelation(notCoveredTriples);
                logstr = "\n\nSorted Triples:"+set.size()+"\n";
                log.write(logstr.getBytes());
                Iterator iterator = set.iterator();
                while (iterator.hasNext()) {
                    Triple Triple = (Triple) iterator.next();
                    if (missedRelationMap.containsKey(Triple.getRelation())) {
                        Integer cnt = missedRelationMap.get(Triple.getRelation());
                        cnt++;
                        missedRelationMap.put(Triple.getRelation(), cnt);
                    }
                    else {
                        missedRelationMap.put(Triple.getRelation(), new Integer(1));
                    }
                    log.write(Triple.toString().getBytes());
                }

                logstr = "\n\nFrequency of missed Triple relations:\n";
                log.write(logstr.getBytes());
                Set keySet = missedRelationMap.keySet();
                Iterator keys = keySet.iterator();
                while (keys.hasNext()) {
                    String key = (String) keys.next();
                    Integer cnt = missedRelationMap.get(key);
                    logstr = key+"\t"+cnt.toString()+"\n";
                    log.write(logstr.getBytes());
                }
                logstr = "\n\nMissed Triples as table relations:\n";
                log.write(logstr.getBytes());
                iterator = set.iterator();
                while (iterator.hasNext()) {
                    Triple Triple = (Triple) iterator.next();
                    logstr = Triple.getElementFirstComment()+":"+Triple.getRelation()+":"+Triple.getElementSecondComment()+"\n";
                    log.write(logstr.getBytes());
                }

                //nCorrectPartialIdTriples
                logstr = "\n\nTriples with partial ID match and correct relations:\n";
                log.write(logstr.getBytes());
                HashMap<String, Integer> rMap = new HashMap<String, Integer> ();
                rMap = new HashMap<String, Integer> ();
                set = Util.sortTriplesForRelation(correctPartialIdExactRelationTriples);
                logstr = "Sorted Triples:"+set.size()+"\n";
                log.write(logstr.getBytes());
                iterator = set.iterator();
                while (iterator.hasNext()) {
                    Triple Triple = (Triple) iterator.next();
                    if (rMap.containsKey(Triple.getRelation())) {
                        Integer cnt = rMap.get(Triple.getRelation());
                        cnt++;
                        rMap.put(Triple.getRelation(), cnt);
                    }
                    else {
                        rMap.put(Triple.getRelation(), new Integer(1));
                    }
                    log.write(Triple.toString().getBytes());
                }

                logstr = "\n\nTriples with partial ID match but wrong relation:\n";
                log.write(logstr.getBytes());

                set = Util.sortTriplesForRelation(wrongRelationTriples);
                logstr = "Sorted Triples:"+set.size()+"\n";
                log.write(logstr.getBytes());
                iterator = set.iterator();
                while (iterator.hasNext()) {
                    Triple Triple = (Triple) iterator.next();
                    if (wrongRelationMap.containsKey(Triple.getRelation())) {
                        Integer cnt = wrongRelationMap.get(Triple.getRelation());
                        cnt++;
                        wrongRelationMap.put(Triple.getRelation(), cnt);
                    }
                    else {
                        wrongRelationMap.put(Triple.getRelation(), new Integer(1));
                    }
                    log.write(Triple.toString().getBytes());
                }
                logstr = "\n\nFrequency of wrong Triple relations:\n";
                log.write(logstr.getBytes());
                keySet = wrongRelationMap.keySet();
                keys = keySet.iterator();
                while (keys.hasNext()) {
                    String key = (String) keys.next();
                    Integer cnt = wrongRelationMap.get(key);
                    logstr = key+"\t"+cnt.toString()+"\n";
                    log.write(logstr.getBytes());
                }

                logstr = "\n\nProfile confusion matrix:\n";
                log.write(logstr.getBytes());
                keySet = profileConfusionMatrix.keySet();
                keys = keySet.iterator();
                TreeSet sorter = new TreeSet();
                while (keys.hasNext()) {
                    String key = (String) keys.next();
                    sorter.add(key);
                }
                keys = sorter.iterator();
                while (keys.hasNext()) {
                    String key = (String) keys.next();
                    logstr = key+"\n";
                    HashMap<String, Integer> map = profileConfusionMatrix.get(key);
                    Set mapSet = map.keySet();
                    Iterator mapKeys = mapSet.iterator();
                    while (mapKeys.hasNext()) {
                        String mapKey = (String) mapKeys.next();
                        Integer cnt = map.get(mapKey);
                        logstr += "\t"+mapKey+"\t"+cnt.toString()+"\n";
                    }
                    log.write(logstr.getBytes());
                }
                log.close();
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }
        }
        this.nSystemTriples = nSystemTriplesInRange;
        this.nSystemTriples = nSystemTriplesInRange;
    }

    public  String printRelationTables () {
        String str = "";
        Set keySet = profileMap.keySet();
        Iterator keys = keySet.iterator();
        str = "\nResults per profile\n";
        str += "Profile\tTotal System\tExactIdExactRelation\tPrecision\tExactId\tPrecision\tPartialIdExactRelation\tPrecision\tPartialId\tPrecision\n";
        while (keys.hasNext()) {
            String key = (String) keys.next();
            Statistics stat = profileMap.get(key);
            str+=key+stat.toStringPrecision();
        }
        int relationCorrectExact = 0;
        int relationCorrectPartial = 0;
        int relationGold = 0;
        int relationSystem = 0;
        str += "\nResults per relation\n";
        keySet = relationMap.keySet();
        keys = keySet.iterator();
        str += "Relation\tTotal gold\tTotal system\tExactIdExactRelation\tRecall\tPrecision\tPartialIdExactRelation\tRecall\tPrecision\n";
        while (keys.hasNext()) {
            String key = (String) keys.next();
            Statistics stat = relationMap.get(key);
            stat.totalSystem = stat.uniqueSystemTriples.size();
            relationCorrectExact += stat.getCorrectExactIdExactRelation();
            relationCorrectPartial += stat.getCorrectPartialIdExactRelation();
            relationGold += stat.getTotalGold();
            relationSystem += stat.getTotalSystem();
            str += key+stat.toStringRelation();
        }
        int totalExactRecall = 0;
        int totalExactPrecision = 0;
        int totalPartialRecall = 0;
        int totalPartialPrecision = 0;
        if (relationGold>0) totalExactRecall = (100*relationCorrectExact)/relationGold;
        if (relationSystem>0) totalExactPrecision = (100*relationCorrectExact)/relationSystem;
        if (relationGold>0) totalPartialRecall = (100*relationCorrectPartial)/relationGold;
        if (relationSystem>0) totalPartialPrecision = (100*relationCorrectPartial)/relationSystem;
        str += "Total\t"+relationGold+"\t"+relationSystem+"\t"+relationCorrectExact+"\t"+totalExactRecall+"\t"+totalExactPrecision+"\t"+relationCorrectPartial+"\t"+totalPartialRecall+"\t"+totalPartialPrecision+"\n";
        return str;
    }

    public String printResults (String goldFile, String systemFile) {
        String str = "\nPrecision and recall figures\n";
        str += "Gold standard\t"+goldFile+"\n";
        str += "\tNr. of Triples\t"+this.nGoldTriples+"\n";
        str += "\tAverage nr. of first element ids\t"+goldParser.getAverageElementFirstIdRange()+"\n";
        str += "\tAverage nr. of second element ids\t"+goldParser.getAverageElementSecondIdRange()+"\n";
        str += "\nSystem file\t"+systemFile+"\n";
        str += "\tNr. of Triples\t"+(nSystemTriples+systemParser.outOfRangeCount)+"\n";
        str += "\tNr. of Triples in range\t"+this.nSystemTriples+"\n";
        str += "\tNr. of Triples out of range\t"+systemParser.outOfRangeCount+"\n";
        str += "\tAverage nr. of first element ids\t"+systemParser.getAverageElementFirstIdRange()+"\n";
        str += "\tAverage nr. of second element ids\t"+systemParser.getAverageElementSecondIdRange()+"\n";
        str += "\tNumber of unique Triples in scope\t"+uniquePartialIdExactRelationTriples.size()+"\n";
        str += "\n";
        str += Util.compareElements(goldParser, systemParser);

/*
        str += "\tNumber of first elements represented in gold standard Triples\t"+(goldParser.nUniqueElementsFirst())+"\n";
        str += "\tNumber of first elements represented in system Triples\t"+(systemParser.nUniqueElementsFirst())+"\n";
        str += "\tNumber of correct first elements represented in system Triples\t"+(systemParser.nUniqueElementsFirstInData())+"\n";
        str += "\tRecall of first elements\t"+(double)systemParser.nUniqueElementsFirstInData()/(double)goldParser.nUniqueElementsFirst()+"\n";
        str += "\tPrecision of first elements\t"+(double)systemParser.nUniqueElementsFirstInData()/(double)systemParser.nUniqueElementsFirst()+"\n";

        str += "\n";
        str += "\tNumber of second elements represented in gold standard Triples\t"+(goldParser.nUniqueElementsSecond())+"\n";
        str += "\tNumber of second elements  represented in system Triples\t"+(systemParser.nUniqueElementsSecond())+"\n";
        str += "\tNumber of correct second elements  represented in system Triples\t"+(systemParser.nUniqueElementsSecondInData())+"\n";
        str += "\tRecall of second elements \t"+(double)systemParser.nUniqueElementsSecondInData()/(double)goldParser.nUniqueElementsSecond()+"\n";
        str += "\tPrecision of second elements \t"+(double)systemParser.nUniqueElementsSecondInData()/(double)systemParser.nUniqueElementsSecond()+"\n";
*/

        dExactIdExactRelationPrecision = (double)this.correctExactIdExactRelationTriples.size()/(double)this.uniqueExactIdExactRelationTriples.size();
        //dExactIdExactRelationPrecision = (double)this.nCorrectExactIdExactRelation/(double)this.nSystemTriples;
        dExactIdExactRelationRecall = (double)this.correctExactIdExactRelationTriples.size()/(double)this.nGoldTriples;
        dPartialIdExactRelationPrecision = (double)this.correctPartialIdExactRelationTriples.size() /(double)this.uniquePartialIdExactRelationTriples.size();
        //dPartialIdExactRelationPrecision = (double)this.nCorrectPartialIdExactRelation /(double)this.nSystemTriples;
        dParialIdExactRelationRecall = (double)this.correctPartialIdExactRelationTriples.size() /(double)this.nGoldTriples;
        dExactIdPrecision = (double)this.correctExactIdTriples.size()/(double)this.uniqueExactIdTriples.size();
        //dExactIdPrecision = (double)this.nCorrectExactId/(double)this.nSystemTriples;
        dExactIdRecall = (double) this.correctExactIdTriples.size()/ (double)this.nGoldTriples;
        dPartialIdPrecision = (double)this.correctPartialIdTriples.size() /(double)this.uniquePartialIdTriples.size();
        //dPartialIdPrecision = (double)this.nCorrectPartialId /(double)this.nSystemTriples;
        dPartialIdRecall = (double)this.correctPartialIdTriples.size() /(double)this.nGoldTriples;

        str += "\nExact identifiers and same relation\n";
        str += "\tNr. correct\t"+ correctExactIdExactRelationTriples.size()+"\n";
        str += "\tPrecision\t"+ dExactIdExactRelationPrecision+"\n";
        str += "\tRecall\t"+ dExactIdExactRelationRecall+"\n";

        str += "\nExact identifiers and ignored relation\n";
        str += "\tNr. correct\t"+ correctExactIdTriples.size()+"\n";
        str += "\tPrecision\t"+ dExactIdPrecision+"\n";
        str += "\tRecall\t"+ dExactIdRecall+"\n";

        str += "\nPartial identifiers and same relation\n";
        str += "\tNr. correct\t"+ correctPartialIdExactRelationTriples.size() +"\n";
        str += "\tPrecision\t"+ dPartialIdExactRelationPrecision+"\n";
        str += "\tRecall\t"+ dParialIdExactRelationRecall+"\n";

        str += "\nPartial identifiers and ignored relation\n";
        str += "\tNr. correct\t"+ correctPartialIdTriples.size() +"\n";
        str += "\tPrecision\t"+ dPartialIdPrecision +"\n";
        str += "\tRecall\t"+ dPartialIdRecall+"\n";

        str+="\n\t"+"Nr of Triples\tTriples inscope\tCorrect\tWSD threshold\tPrecision\tRecall\n";
        str+=""+systemFile+"\t"+(this.nSystemTriples+systemParser.outOfRangeCount)+"\t"+uniquePartialIdExactRelationTriples.size()+"\t"+correctPartialIdExactRelationTriples.size()+"\t\t"+dPartialIdExactRelationPrecision+"\t"+dParialIdExactRelationRecall+"\n";

        return str;
    }

    public void printStatistics (String fileName, TripleSaxParser parser) {
        String str = parser.message;
        ArrayList<String> firstElements = new ArrayList<String>();
        HashMap<String, Integer> relations = new HashMap<String, Integer>();
        for (int i = 0; i < parser.data.size(); i++) {
            Triple Triple = parser.data.get(i);
            if (!firstElements.contains(Triple.getTripleId())) {
                firstElements.add(Triple.getTripleId());
            }
            if (relations.containsKey(Triple.getRelation())) {
                Integer cnt = relations.get(Triple.getRelation());
                cnt++;
                relations.put(Triple.getRelation(), cnt);
            }
            else {
                relations.put(Triple.getRelation(), new Integer(1));
            }
        }
        str += "Nr of Triple ids:\t"+firstElements.size()+"\n";
        str += "Nr of relations:\t"+relations.size()+"\n";
        str += "Total nr of second elements:\t"+parser.data.size()+"\n\n";
        str += "Relations:\n";
        Set keySet = relations.keySet();
        Iterator keys = keySet.iterator();
        while (keys.hasNext()) {
            String key = (String) keys.next();
            Integer cnt = relations.get(key);
            Double perc = 100*(double)cnt/(double)parser.data.size();
            str += key+"\t"+cnt.toString()+"\t"+perc.intValue()+"%\n";
        }
        if (fos!=null) {
            try {
            fos.write(str.getBytes());
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }
        }
    }

    public String readTokenRange (String tokenRangeFile) {
        String str = "";
        try {
          str += "tokenRangeFile:\t" + tokenRangeFile+"\n";
          FileInputStream fis = new FileInputStream(tokenRangeFile);
          InputStreamReader isr = new InputStreamReader(fis);
          BufferedReader in = new BufferedReader(isr);
          String inputLine;
          while ((inputLine = in.readLine()) != null) {
              String token = inputLine.trim();
              if (token.length()>0) {
                  if (!tokenRange.contains(token)) {
                      tokenRange.add(token);
                  }
              }
          }
          in.close();
          str += "tokenRange:\t" + tokenRange.size()+"\n";
        }
        catch (Exception eee) {
          String error = "\nException --"+eee.getMessage();
          System.out.println(error);
        }
        return str;
    }




    static public void main (String[] args) {
        EvaluateTriplesDebug evaluation = new EvaluateTriplesDebug();
        String goldStandardTripleFile = "";
        String systemTripleFile = "";
        String tokenRangeFile = "";
        for (int i = 0; i < args.length; i++) {
            String arg = args[i];
            if (arg.equalsIgnoreCase("--gold-standard-triples")) {
               if (i+1<args.length) {
                    goldStandardTripleFile = args[i+1];
               }
               else {
                   System.out.println("NO FILE PROVIDED!");
               }
            }
            else if (arg.equalsIgnoreCase("--system-triples")) {
                if (i+1<args.length) {
                   systemTripleFile = args[i+1];
                }
                else {
                    System.out.println("NO FILE PROVIDED!");
                }
            }
            else if (arg.equalsIgnoreCase("--token-range")) {
                if (i+1<args.length) {
                   tokenRangeFile = args[i+1];

                }
                else {
                    System.out.println("NO FILE PROVIDED!");
                }
            }
            else if (arg.equalsIgnoreCase("--ignore-element-second")) {
                evaluation.elementSecondMatch = false;
            }
            else if (arg.equalsIgnoreCase("--skip-time-and-location")) {
                evaluation.timeAndLocation = false;

            }
        }
        if ((goldStandardTripleFile.length()>0) && (systemTripleFile.length()>0)) {
            try {
                evaluation.fos = new FileOutputStream(systemTripleFile+".xls");
                evaluation.log = new FileOutputStream(systemTripleFile+".log");
                System.out.println("goldStandardTripleFile = " + goldStandardTripleFile);
                System.out.println("systemTripleFile = " + systemTripleFile);
                System.out.println("tokenRangeFile = " + tokenRangeFile);
                System.out.println("evaluation.timeAndLocation = " + evaluation.timeAndLocation);
                String str ="";
                if (tokenRangeFile.length()>0) {
                    str = evaluation.readTokenRange(tokenRangeFile);
                    evaluation.fos.write(str.getBytes());
                }
                evaluation.compareTripleFiles(goldStandardTripleFile, systemTripleFile);
                str = evaluation.printResults(new File(goldStandardTripleFile).getName(), new File(systemTripleFile).getName());
                evaluation.fos.write(str.getBytes());
                str = evaluation.printRelationTables();
                evaluation.fos.write(str.getBytes());
                evaluation.fos.close();
            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }
        }
        else {
            String usage = "";
            usage += "--gold-standard-triples file with gold standard triples\n";
            usage += "--system-triples file with system triples\n";
            usage += "--token-range (optional) file with tokens for the first elements to be covered\n";
            usage += "--ignore-element-second (optional) lumps differentiated second elements as a single typed relation\n";
            usage += "--skip-time-and-location (optional) TIME and LOCATION relations are ignored\n";
            System.out.println("usage =\n" + usage);
        }
    }

}
